//
//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
//

//
//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct StorageServiceProtos_StorageItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var key: Data = SwiftProtobuf.Internal.emptyData

  /// @required
  var value: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_StorageItems {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Corresponds to the requested
  var items: [StorageServiceProtos_StorageItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_StorageManifest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var version: UInt64 = 0

  /// @required
  var value: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_ReadOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var readKey: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_WriteOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var manifest: StorageServiceProtos_StorageManifest {
    get {return _manifest ?? StorageServiceProtos_StorageManifest()}
    set {_manifest = newValue}
  }
  /// Returns true if `manifest` has been explicitly set.
  var hasManifest: Bool {return self._manifest != nil}
  /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
  mutating func clearManifest() {self._manifest = nil}

  var insertItem: [StorageServiceProtos_StorageItem] = []

  var deleteKey: [Data] = []

  var deleteAll: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _manifest: StorageServiceProtos_StorageManifest?
}

struct StorageServiceProtos_ManifestRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var version: UInt64 = 0

  var keys: [StorageServiceProtos_ManifestRecord.Key] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Key {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var data: Data = SwiftProtobuf.Internal.emptyData

    /// @required
    var type: StorageServiceProtos_ManifestRecord.Key.TypeEnum = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case contact // = 1
      case groupv1 // = 2
      case groupv2 // = 3
      case account // = 4
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contact
        case 2: self = .groupv1
        case 3: self = .groupv2
        case 4: self = .account
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contact: return 1
        case .groupv1: return 2
        case .groupv2: return 3
        case .account: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension StorageServiceProtos_ManifestRecord.Key.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [StorageServiceProtos_ManifestRecord.Key.TypeEnum] = [
    .unknown,
    .contact,
    .groupv1,
    .groupv2,
    .account
  ]
}

#endif  // swift(>=4.2)

struct StorageServiceProtos_StorageRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var record: StorageServiceProtos_StorageRecord.OneOf_Record?

  var contact: StorageServiceProtos_ContactRecord {
    get {
      if case .contact(let v)? = record {return v}
      return StorageServiceProtos_ContactRecord()
    }
    set {record = .contact(newValue)}
  }

  var groupV1: StorageServiceProtos_GroupV1Record {
    get {
      if case .groupV1(let v)? = record {return v}
      return StorageServiceProtos_GroupV1Record()
    }
    set {record = .groupV1(newValue)}
  }

  var groupV2: StorageServiceProtos_GroupV2Record {
    get {
      if case .groupV2(let v)? = record {return v}
      return StorageServiceProtos_GroupV2Record()
    }
    set {record = .groupV2(newValue)}
  }

  var account: StorageServiceProtos_AccountRecord {
    get {
      if case .account(let v)? = record {return v}
      return StorageServiceProtos_AccountRecord()
    }
    set {record = .account(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Record: Equatable {
    case contact(StorageServiceProtos_ContactRecord)
    case groupV1(StorageServiceProtos_GroupV1Record)
    case groupV2(StorageServiceProtos_GroupV2Record)
    case account(StorageServiceProtos_AccountRecord)

  #if !swift(>=4.1)
    static func ==(lhs: StorageServiceProtos_StorageRecord.OneOf_Record, rhs: StorageServiceProtos_StorageRecord.OneOf_Record) -> Bool {
      switch (lhs, rhs) {
      case (.contact(let l), .contact(let r)): return l == r
      case (.groupV1(let l), .groupV1(let r)): return l == r
      case (.groupV2(let l), .groupV2(let r)): return l == r
      case (.account(let l), .account(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct StorageServiceProtos_ContactRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @trustedMapping
  var serviceUuid: String = String()

  var serviceE164: String = String()

  var profileKey: Data = SwiftProtobuf.Internal.emptyData

  var identityKey: Data = SwiftProtobuf.Internal.emptyData

  var identityState: StorageServiceProtos_ContactRecord.IdentityState = .default

  var givenName: String = String()

  var familyName: String = String()

  var username: String = String()

  var blocked: Bool = false

  var whitelisted: Bool = false

  var archived: Bool = false

  var markedUnread: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum IdentityState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case `default` // = 0
    case verified // = 1
    case unverified // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .verified
      case 2: self = .unverified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .verified: return 1
      case .unverified: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension StorageServiceProtos_ContactRecord.IdentityState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [StorageServiceProtos_ContactRecord.IdentityState] = [
    .default,
    .verified,
    .unverified
  ]
}

#endif  // swift(>=4.2)

struct StorageServiceProtos_GroupV1Record {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: Data = SwiftProtobuf.Internal.emptyData

  var blocked: Bool = false

  var whitelisted: Bool = false

  var archived: Bool = false

  var markedUnread: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_GroupV2Record {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var masterKey: Data = SwiftProtobuf.Internal.emptyData

  var blocked: Bool = false

  var whitelisted: Bool = false

  var archived: Bool = false

  var markedUnread: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_AccountRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var profileKey: Data = SwiftProtobuf.Internal.emptyData

  var givenName: String = String()

  var familyName: String = String()

  var avatarURL: String = String()

  var noteToSelfArchived: Bool = false

  var readReceipts: Bool = false

  var sealedSenderIndicators: Bool = false

  var typingIndicators: Bool = false

  /// Legacy link previews flag
  var proxiedLinkPreviews: Bool = false

  var noteToSelfMarkedUnread: Bool = false

  var linkPreviews: Bool = false

  var phoneNumberSharingMode: StorageServiceProtos_AccountRecord.PhoneNumberSharingMode = .everybody

  var notDiscoverableByPhoneNumber: Bool = false

  var pinnedConversations: [StorageServiceProtos_AccountRecord.PinnedConversation] = []

  var preferContactAvatars: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PhoneNumberSharingMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case everybody // = 0
    case contactsOnly // = 1
    case nobody // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .everybody
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .everybody
      case 1: self = .contactsOnly
      case 2: self = .nobody
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .everybody: return 0
      case .contactsOnly: return 1
      case .nobody: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct PinnedConversation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: StorageServiceProtos_AccountRecord.PinnedConversation.OneOf_Identifier?

    var contact: StorageServiceProtos_AccountRecord.PinnedConversation.Contact {
      get {
        if case .contact(let v)? = identifier {return v}
        return StorageServiceProtos_AccountRecord.PinnedConversation.Contact()
      }
      set {identifier = .contact(newValue)}
    }

    var legacyGroupID: Data {
      get {
        if case .legacyGroupID(let v)? = identifier {return v}
        return SwiftProtobuf.Internal.emptyData
      }
      set {identifier = .legacyGroupID(newValue)}
    }

    var groupMasterKey: Data {
      get {
        if case .groupMasterKey(let v)? = identifier {return v}
        return SwiftProtobuf.Internal.emptyData
      }
      set {identifier = .groupMasterKey(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Identifier: Equatable {
      case contact(StorageServiceProtos_AccountRecord.PinnedConversation.Contact)
      case legacyGroupID(Data)
      case groupMasterKey(Data)

    #if !swift(>=4.1)
      static func ==(lhs: StorageServiceProtos_AccountRecord.PinnedConversation.OneOf_Identifier, rhs: StorageServiceProtos_AccountRecord.PinnedConversation.OneOf_Identifier) -> Bool {
        switch (lhs, rhs) {
        case (.contact(let l), .contact(let r)): return l == r
        case (.legacyGroupID(let l), .legacyGroupID(let r)): return l == r
        case (.groupMasterKey(let l), .groupMasterKey(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    struct Contact {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var uuid: String = String()

      var e164: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension StorageServiceProtos_AccountRecord.PhoneNumberSharingMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [StorageServiceProtos_AccountRecord.PhoneNumberSharingMode] = [
    .everybody,
    .contactsOnly,
    .nobody
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "StorageServiceProtos"

extension StorageServiceProtos_StorageItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.key)
      case 2: try decoder.decodeSingularBytesField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageItem, rhs: StorageServiceProtos_StorageItem) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_StorageItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageItems"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.items)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageItems, rhs: StorageServiceProtos_StorageItems) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_StorageManifest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageManifest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "value")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.version)
      case 2: try decoder.decodeSingularBytesField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageManifest, rhs: StorageServiceProtos_StorageManifest) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ReadOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "readKey")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.readKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.readKey.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.readKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ReadOperation, rhs: StorageServiceProtos_ReadOperation) -> Bool {
    if lhs.readKey != rhs.readKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_WriteOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
    2: .same(proto: "insertItem"),
    3: .same(proto: "deleteKey"),
    4: .same(proto: "deleteAll")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._manifest)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.insertItem)
      case 3: try decoder.decodeRepeatedBytesField(value: &self.deleteKey)
      case 4: try decoder.decodeSingularBoolField(value: &self.deleteAll)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._manifest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.insertItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insertItem, fieldNumber: 2)
    }
    if !self.deleteKey.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.deleteKey, fieldNumber: 3)
    }
    if self.deleteAll != false {
      try visitor.visitSingularBoolField(value: self.deleteAll, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_WriteOperation, rhs: StorageServiceProtos_WriteOperation) -> Bool {
    if lhs._manifest != rhs._manifest {return false}
    if lhs.insertItem != rhs.insertItem {return false}
    if lhs.deleteKey != rhs.deleteKey {return false}
    if lhs.deleteAll != rhs.deleteAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ManifestRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManifestRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "keys")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.version)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.keys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ManifestRecord, rhs: StorageServiceProtos_ManifestRecord) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ManifestRecord.Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_ManifestRecord.protoMessageName + ".Key"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "type")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.data)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ManifestRecord.Key, rhs: StorageServiceProtos_ManifestRecord.Key) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ManifestRecord.Key.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTACT"),
    2: .same(proto: "GROUPV1"),
    3: .same(proto: "GROUPV2"),
    4: .same(proto: "ACCOUNT")
  ]
}

extension StorageServiceProtos_StorageRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    2: .same(proto: "groupV1"),
    3: .same(proto: "groupV2"),
    4: .same(proto: "account")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: StorageServiceProtos_ContactRecord?
        if let current = self.record {
          try decoder.handleConflictingOneOf()
          if case .contact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.record = .contact(v)}
      case 2:
        var v: StorageServiceProtos_GroupV1Record?
        if let current = self.record {
          try decoder.handleConflictingOneOf()
          if case .groupV1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.record = .groupV1(v)}
      case 3:
        var v: StorageServiceProtos_GroupV2Record?
        if let current = self.record {
          try decoder.handleConflictingOneOf()
          if case .groupV2(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.record = .groupV2(v)}
      case 4:
        var v: StorageServiceProtos_AccountRecord?
        if let current = self.record {
          try decoder.handleConflictingOneOf()
          if case .account(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.record = .account(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.record {
    case .contact(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .groupV1(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .groupV2(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .account(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageRecord, rhs: StorageServiceProtos_StorageRecord) -> Bool {
    if lhs.record != rhs.record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ContactRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceUuid"),
    2: .same(proto: "serviceE164"),
    3: .same(proto: "profileKey"),
    4: .same(proto: "identityKey"),
    5: .same(proto: "identityState"),
    6: .same(proto: "givenName"),
    7: .same(proto: "familyName"),
    8: .same(proto: "username"),
    9: .same(proto: "blocked"),
    10: .same(proto: "whitelisted"),
    11: .same(proto: "archived"),
    12: .same(proto: "markedUnread")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.serviceUuid)
      case 2: try decoder.decodeSingularStringField(value: &self.serviceE164)
      case 3: try decoder.decodeSingularBytesField(value: &self.profileKey)
      case 4: try decoder.decodeSingularBytesField(value: &self.identityKey)
      case 5: try decoder.decodeSingularEnumField(value: &self.identityState)
      case 6: try decoder.decodeSingularStringField(value: &self.givenName)
      case 7: try decoder.decodeSingularStringField(value: &self.familyName)
      case 8: try decoder.decodeSingularStringField(value: &self.username)
      case 9: try decoder.decodeSingularBoolField(value: &self.blocked)
      case 10: try decoder.decodeSingularBoolField(value: &self.whitelisted)
      case 11: try decoder.decodeSingularBoolField(value: &self.archived)
      case 12: try decoder.decodeSingularBoolField(value: &self.markedUnread)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 1)
    }
    if !self.serviceE164.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceE164, fieldNumber: 2)
    }
    if !self.profileKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.profileKey, fieldNumber: 3)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKey, fieldNumber: 4)
    }
    if self.identityState != .default {
      try visitor.visitSingularEnumField(value: self.identityState, fieldNumber: 5)
    }
    if !self.givenName.isEmpty {
      try visitor.visitSingularStringField(value: self.givenName, fieldNumber: 6)
    }
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 7)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 8)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 9)
    }
    if self.whitelisted != false {
      try visitor.visitSingularBoolField(value: self.whitelisted, fieldNumber: 10)
    }
    if self.archived != false {
      try visitor.visitSingularBoolField(value: self.archived, fieldNumber: 11)
    }
    if self.markedUnread != false {
      try visitor.visitSingularBoolField(value: self.markedUnread, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ContactRecord, rhs: StorageServiceProtos_ContactRecord) -> Bool {
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.serviceE164 != rhs.serviceE164 {return false}
    if lhs.profileKey != rhs.profileKey {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.identityState != rhs.identityState {return false}
    if lhs.givenName != rhs.givenName {return false}
    if lhs.familyName != rhs.familyName {return false}
    if lhs.username != rhs.username {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.whitelisted != rhs.whitelisted {return false}
    if lhs.archived != rhs.archived {return false}
    if lhs.markedUnread != rhs.markedUnread {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ContactRecord.IdentityState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "VERIFIED"),
    2: .same(proto: "UNVERIFIED")
  ]
}

extension StorageServiceProtos_GroupV1Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupV1Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "blocked"),
    3: .same(proto: "whitelisted"),
    4: .same(proto: "archived"),
    5: .same(proto: "markedUnread")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.id)
      case 2: try decoder.decodeSingularBoolField(value: &self.blocked)
      case 3: try decoder.decodeSingularBoolField(value: &self.whitelisted)
      case 4: try decoder.decodeSingularBoolField(value: &self.archived)
      case 5: try decoder.decodeSingularBoolField(value: &self.markedUnread)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 2)
    }
    if self.whitelisted != false {
      try visitor.visitSingularBoolField(value: self.whitelisted, fieldNumber: 3)
    }
    if self.archived != false {
      try visitor.visitSingularBoolField(value: self.archived, fieldNumber: 4)
    }
    if self.markedUnread != false {
      try visitor.visitSingularBoolField(value: self.markedUnread, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_GroupV1Record, rhs: StorageServiceProtos_GroupV1Record) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.whitelisted != rhs.whitelisted {return false}
    if lhs.archived != rhs.archived {return false}
    if lhs.markedUnread != rhs.markedUnread {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_GroupV2Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupV2Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "masterKey"),
    2: .same(proto: "blocked"),
    3: .same(proto: "whitelisted"),
    4: .same(proto: "archived"),
    5: .same(proto: "markedUnread")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.masterKey)
      case 2: try decoder.decodeSingularBoolField(value: &self.blocked)
      case 3: try decoder.decodeSingularBoolField(value: &self.whitelisted)
      case 4: try decoder.decodeSingularBoolField(value: &self.archived)
      case 5: try decoder.decodeSingularBoolField(value: &self.markedUnread)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.masterKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.masterKey, fieldNumber: 1)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 2)
    }
    if self.whitelisted != false {
      try visitor.visitSingularBoolField(value: self.whitelisted, fieldNumber: 3)
    }
    if self.archived != false {
      try visitor.visitSingularBoolField(value: self.archived, fieldNumber: 4)
    }
    if self.markedUnread != false {
      try visitor.visitSingularBoolField(value: self.markedUnread, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_GroupV2Record, rhs: StorageServiceProtos_GroupV2Record) -> Bool {
    if lhs.masterKey != rhs.masterKey {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.whitelisted != rhs.whitelisted {return false}
    if lhs.archived != rhs.archived {return false}
    if lhs.markedUnread != rhs.markedUnread {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profileKey"),
    2: .same(proto: "givenName"),
    3: .same(proto: "familyName"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "noteToSelfArchived"),
    6: .same(proto: "readReceipts"),
    7: .same(proto: "sealedSenderIndicators"),
    8: .same(proto: "typingIndicators"),
    9: .same(proto: "proxiedLinkPreviews"),
    10: .same(proto: "noteToSelfMarkedUnread"),
    11: .same(proto: "linkPreviews"),
    12: .same(proto: "phoneNumberSharingMode"),
    13: .same(proto: "notDiscoverableByPhoneNumber"),
    14: .same(proto: "pinnedConversations"),
    15: .same(proto: "preferContactAvatars")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.profileKey)
      case 2: try decoder.decodeSingularStringField(value: &self.givenName)
      case 3: try decoder.decodeSingularStringField(value: &self.familyName)
      case 4: try decoder.decodeSingularStringField(value: &self.avatarURL)
      case 5: try decoder.decodeSingularBoolField(value: &self.noteToSelfArchived)
      case 6: try decoder.decodeSingularBoolField(value: &self.readReceipts)
      case 7: try decoder.decodeSingularBoolField(value: &self.sealedSenderIndicators)
      case 8: try decoder.decodeSingularBoolField(value: &self.typingIndicators)
      case 9: try decoder.decodeSingularBoolField(value: &self.proxiedLinkPreviews)
      case 10: try decoder.decodeSingularBoolField(value: &self.noteToSelfMarkedUnread)
      case 11: try decoder.decodeSingularBoolField(value: &self.linkPreviews)
      case 12: try decoder.decodeSingularEnumField(value: &self.phoneNumberSharingMode)
      case 13: try decoder.decodeSingularBoolField(value: &self.notDiscoverableByPhoneNumber)
      case 14: try decoder.decodeRepeatedMessageField(value: &self.pinnedConversations)
      case 15: try decoder.decodeSingularBoolField(value: &self.preferContactAvatars)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.profileKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.profileKey, fieldNumber: 1)
    }
    if !self.givenName.isEmpty {
      try visitor.visitSingularStringField(value: self.givenName, fieldNumber: 2)
    }
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if self.noteToSelfArchived != false {
      try visitor.visitSingularBoolField(value: self.noteToSelfArchived, fieldNumber: 5)
    }
    if self.readReceipts != false {
      try visitor.visitSingularBoolField(value: self.readReceipts, fieldNumber: 6)
    }
    if self.sealedSenderIndicators != false {
      try visitor.visitSingularBoolField(value: self.sealedSenderIndicators, fieldNumber: 7)
    }
    if self.typingIndicators != false {
      try visitor.visitSingularBoolField(value: self.typingIndicators, fieldNumber: 8)
    }
    if self.proxiedLinkPreviews != false {
      try visitor.visitSingularBoolField(value: self.proxiedLinkPreviews, fieldNumber: 9)
    }
    if self.noteToSelfMarkedUnread != false {
      try visitor.visitSingularBoolField(value: self.noteToSelfMarkedUnread, fieldNumber: 10)
    }
    if self.linkPreviews != false {
      try visitor.visitSingularBoolField(value: self.linkPreviews, fieldNumber: 11)
    }
    if self.phoneNumberSharingMode != .everybody {
      try visitor.visitSingularEnumField(value: self.phoneNumberSharingMode, fieldNumber: 12)
    }
    if self.notDiscoverableByPhoneNumber != false {
      try visitor.visitSingularBoolField(value: self.notDiscoverableByPhoneNumber, fieldNumber: 13)
    }
    if !self.pinnedConversations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pinnedConversations, fieldNumber: 14)
    }
    if self.preferContactAvatars != false {
      try visitor.visitSingularBoolField(value: self.preferContactAvatars, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord, rhs: StorageServiceProtos_AccountRecord) -> Bool {
    if lhs.profileKey != rhs.profileKey {return false}
    if lhs.givenName != rhs.givenName {return false}
    if lhs.familyName != rhs.familyName {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.noteToSelfArchived != rhs.noteToSelfArchived {return false}
    if lhs.readReceipts != rhs.readReceipts {return false}
    if lhs.sealedSenderIndicators != rhs.sealedSenderIndicators {return false}
    if lhs.typingIndicators != rhs.typingIndicators {return false}
    if lhs.proxiedLinkPreviews != rhs.proxiedLinkPreviews {return false}
    if lhs.noteToSelfMarkedUnread != rhs.noteToSelfMarkedUnread {return false}
    if lhs.linkPreviews != rhs.linkPreviews {return false}
    if lhs.phoneNumberSharingMode != rhs.phoneNumberSharingMode {return false}
    if lhs.notDiscoverableByPhoneNumber != rhs.notDiscoverableByPhoneNumber {return false}
    if lhs.pinnedConversations != rhs.pinnedConversations {return false}
    if lhs.preferContactAvatars != rhs.preferContactAvatars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord.PhoneNumberSharingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVERYBODY"),
    1: .same(proto: "CONTACTS_ONLY"),
    2: .same(proto: "NOBODY")
  ]
}

extension StorageServiceProtos_AccountRecord.PinnedConversation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_AccountRecord.protoMessageName + ".PinnedConversation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    3: .same(proto: "legacyGroupId"),
    4: .same(proto: "groupMasterKey")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: StorageServiceProtos_AccountRecord.PinnedConversation.Contact?
        if let current = self.identifier {
          try decoder.handleConflictingOneOf()
          if case .contact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.identifier = .contact(v)}
      case 3:
        if self.identifier != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.identifier = .legacyGroupID(v)}
      case 4:
        if self.identifier != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.identifier = .groupMasterKey(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.identifier {
    case .contact(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .legacyGroupID(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    case .groupMasterKey(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord.PinnedConversation, rhs: StorageServiceProtos_AccountRecord.PinnedConversation) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord.PinnedConversation.Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_AccountRecord.PinnedConversation.protoMessageName + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "e164")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.uuid)
      case 2: try decoder.decodeSingularStringField(value: &self.e164)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.e164.isEmpty {
      try visitor.visitSingularStringField(value: self.e164, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord.PinnedConversation.Contact, rhs: StorageServiceProtos_AccountRecord.PinnedConversation.Contact) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.e164 != rhs.e164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
